# 時間複雜度（Big-O Notation）

------

## 🧠 什麼是時間複雜度（Big-O Notation）？

### 💡 白話定義：

> **時間複雜度 O(...) 是一種描述「程式執行時間會怎樣隨著輸入大小改變」的數學表示法。**

它不告訴你「具體需要幾秒」，但會告訴你「如果資料變 10 倍，時間大概變幾倍」。

------

## 📦 常見的時間複雜度對照表

| 複雜度     | 對應意思               | 如果資料量是 n = 1000 |
| ---------- | ---------------------- | --------------------- |
| O(1)       | 常數時間，不變         | 很快，1 次操作        |
| O(log n)   | 對半切，每次減一半     | 大約跑 10 次          |
| O(n)       | 每一筆都要處理         | 要跑 1000 次          |
| O(n log n) | 跑一圈還要再分組處理   | 約 10,000 次          |
| O(n²)      | 每筆對每筆（巢狀迴圈） | 跑百萬次，很慢        |

------

## 🏪 比喻：便利商店買東西的時間複雜度

| 類型     | 說明                                                |
| -------- | --------------------------------------------------- |
| O(1)     | 櫃檯問：「找 10 元硬幣？」只要打開抽屜就行          |
| O(n)     | 你要找商品「牛奶」，只能一排一排慢慢找              |
| O(log n) | 商品都照類別分層 → 每次縮小一半範圍來找（像猜數字） |

------

## 🧪 例子 1：O(n)

```c
int sum(int arr[], int n) {
    int total = 0;
    for (int i = 0; i < n; i++) {
        total += arr[i];
    }
    return total;
}
```

- 這段程式會 **逐個處理每一筆資料**
- 所以時間是「跟 n 成正比」 → O(n)

------

## 🧪 例子 2：O(log n)

```c
int binarySearch(int arr[], int n, int target) {
    int left = 0, right = n - 1;
    while (left <= right) {
        int mid = (left + right) / 2;
        if (arr[mid] == target)
            return mid;
        else if (arr[mid] < target)
            left = mid + 1;
        else
            right = mid - 1;
    }
    return -1;
}
```

- 每次都把資料切一半來查找
- 所以只要 `log₂(n)` 次就能找到 → O(log n)

------

## ⏱️ 如何「算出」複雜度？

你只要看程式碼中：

| 看什麼                      | 解釋       |
| --------------------------- | ---------- |
| 一層 for 跑 n 次            | O(n)       |
| 兩層 for 彼此巢狀           | O(n²)      |
| 每次變成一半（除以 2）      | O(log n)   |
| for + log（例如分組後排序） | O(n log n) |

------

## 🧠 應用在 Segment Tree 上

### 為什麼查詢是 O(log n)？

因為每次查詢一個範圍時，你只要走「最多 log₂(n) 層」，例如：

- 8 個數 → 樹高 = 3（因為 2³ = 8）
- 每層查一次就可以知道你要的答案在哪裡

這就像你在搜尋電話簿，快速對半縮小查找範圍。

------

## ✅ 小結

| 重點                                           | 說明                       |
| ---------------------------------------------- | -------------------------- |
| O 是一種「描述規模變化」的方式                 | 幫你知道程式效能會不會爆炸 |
| 不在乎執行幾秒，而是「輸入多了會不會變慢很多」 |                            |
| 用 `for` 看執行次數的變化就能估算出 O 的型態   |                            |

------

這是學演算法時常見的疑惑。

------

## ✅ 簡短回答：

> **是的，log₂(n)** 和 **log n** 在時間複雜度（Big-O）中通常被視為**相同的東西**，因為：
>
> - **底數不同只差一個常數倍**
> - **Big-O 會忽略常數倍的差異**

------

## 🔍 詳細說明：

### 1️⃣ log₂(n) 是以 **2 為底** 的對數

- 意思是：「2 的幾次方等於 n？」
- 例如：
  - log₂(8) = 3（因為 2³ = 8）
  - log₂(16) = 4（因為 2⁴ = 16）

### 2️⃣ log₁₀(n) 是以 **10 為底**（常用在數學）

- log₁₀(1000) = 3（10³ = 1000）

### 3️⃣ logₑ(n)（ln）是自然對數（底數是 e ≈ 2.718）

- 用在數學、機率統計上比較多

------

## 🧠 Big-O 中為什麼底數不重要？

因為在 Big-O 中，我們只看**輸入規模變化趨勢**，忽略底數的差異，因為：

> 所有底數之間都可以互相轉換，只差一個「常數倍」：

```plaintext
logₐ(n) = log_b(n) / log_b(a)
```

例如：

```plaintext
log₂(n) = log₁₀(n) / log₁₀(2) ≈ log₁₀(n) / 0.3010
```

也就是說：

> **log₂(n) ≈ 3.32 × log₁₀(n)** → 差一個常數，不影響 Big-O 分析。

------

## 🔧 在程式語言中會用哪一種 log？

| 語言 / 函式                        | 說明                      |
| ---------------------------------- | ------------------------- |
| C 語言的 `log(n)`（在 `<math.h>`） | 以 **e 為底**（自然對數） |
| C 語言的 `log10(n)`                | 以 10 為底                |
| `log2(n)`（部分語言支援）          | 以 2 為底，明確指定       |

⚠️ 如果你真的需要「以 2 為底」的結果但語言只提供自然對數，你可以自己換底：

```c
log2(n) = log(n) / log(2)
```

------

## 📌 結論

| 問題                          | 答案                       |
| ----------------------------- | -------------------------- |
| log₂(n) 和 log n 是一樣的嗎？ | ✅ 在 Big-O 中 **視為相同** |
| 差在哪？                      | 底數不同，只差一個常數倍   |
| Big-O 會在乎這個常數嗎？      | ❌ 不會（Big-O 忽略常數）   |

------

